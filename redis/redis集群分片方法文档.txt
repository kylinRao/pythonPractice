D:\APPS\Anaconda2\python.exe D:/projects/github/pythonPractice/redis/interRedisCli.py
input 0 to use conf\DC.dev.pro
input 1 to use conf\10.22\dc.txt

input you selection />1
['192.168.1.113', '7000']
conf\10.22\dc.txt />get a
Help on StrictRedisCluster in module rediscluster.client object:

class StrictRedisCluster(redis.client.StrictRedis)
 |  If a command is implemented over the one in StrictRedis then it requires some changes compared to
 |  the regular implementation of the method.
 |
 |  Method resolution order:
 |      StrictRedisCluster
 |      redis.client.StrictRedis
 |      __builtin__.object
 |
 |  Methods defined here:
 |
 |  __init__(self, host=None, port=None, startup_nodes=None, max_connections=32, max_connections_per_node=False, init_slot_cache=True, readonly_mode=False, reinitialize_steps=None, skip_full_coverage_check=False, nodemanager_follow_cluster=False, **kwargs)
 |      :startup_nodes:
 |          List of nodes that initial bootstrapping can be done from
 |      :host:
 |          Can be used to point to a startup node
 |      :port:
 |          Can be used to point to a startup node
 |      :max_connections:
 |          Maximum number of connections that should be kept open at one time
 |      :readonly_mode:
 |          enable READONLY mode. You can read possibly stale data from slave.
 |      :skip_full_coverage_check:
 |          Skips the check of cluster-require-full-coverage config, useful for clusters
 |          without the CONFIG command (like aws)
 |      :nodemanager_follow_cluster:
 |          The node manager will during initialization try the last set of nodes that
 |          it was operating on. This will allow the client to drift along side the cluster
 |          if the cluster nodes move around alot.
 |      :**kwargs:
 |          Extra arguments that will be sent into StrictRedis instance when created
 |          (See Official redis-py doc for supported kwargs
 |          [https://github.com/andymccurdy/redis-py/blob/master/redis/client.py])
 |          Some kwargs is not supported and will raise RedisClusterException
 |          - db (Redis do not support database SELECT in cluster mode)
 |
 |  __repr__(self)
 |
 |  brpoplpush(self, src, dst, timeout=0)
 |      Pop a value off the tail of ``src``, push it on the head of ``dst``
 |      and then return it.
 |
 |      This command blocks until a value is in ``src`` or until ``timeout``
 |      seconds elapse, whichever is first. A ``timeout`` value of 0 blocks
 |      forever.
 |
 |      Cluster impl:
 |          Call brpop() then send the result into lpush()
 |
 |          Operation is no longer atomic.
 |
 |  cluster_addslots(self, node_id, *slots)
 |      Assign new hash slots to receiving node
 |
 |      Sends to specefied node
 |
 |  cluster_count_failure_report(self, node_id)
 |      Return the number of failure reports active for a given node
 |
 |      Sends to specefied node
 |
 |  cluster_countkeysinslot(self, slot_id)
 |      Return the number of local keys in the specified hash slot
 |
 |      Send to node based on specefied slot_id
 |
 |  cluster_delslots(self, *slots)
 |      Set hash slots as unbound in the cluster.
 |      It determines by it self what node the slot is in and sends it there
 |
 |      Returns a list of the results for each processed slot.
 |
 |  cluster_failover(self, node_id, option)
 |      Forces a slave to perform a manual failover of its master
 |
 |      Sends to specefied node
 |
 |  cluster_info(self)
 |      Provides info about Redis Cluster node state
 |
 |      Sends to random node in the cluster
 |
 |  cluster_keyslot(self, name)
 |      Returns the hash slot of the specified key
 |
 |      Sends to random node in the cluster
 |
 |  cluster_meet(self, node_id, host, port)
 |      Force a node cluster to handshake with another node.
 |
 |      Sends to specefied node
 |
 |  cluster_nodes(self)
 |      Force a node cluster to handshake with another node
 |
 |      Sends to random node in the cluster
 |
 |  cluster_replicate(self, target_node_id)
 |      Reconfigure a node as a slave of the specified master node
 |
 |      Sends to specefied node
 |
 |  cluster_reset(self, node_id, soft=True)
 |      Reset a Redis Cluster node
 |
 |      If 'soft' is True then it will send 'SOFT' argument
 |      If 'soft' is False then it will send 'HARD' argument
 |
 |      Sends to specefied node
 |
 |  cluster_reset_all_nodes(self, soft=True)
 |      Send CLUSTER RESET to all nodes in the cluster
 |
 |      If 'soft' is True then it will send 'SOFT' argument
 |      If 'soft' is False then it will send 'HARD' argument
 |
 |      Sends to all nodes in the cluster
 |
 |  cluster_save_config(self)
 |      Forces the node to save cluster state on disk
 |
 |      Sends to all nodes in the cluster
 |
 |  cluster_set_config_epoch(self, node_id, epoch)
 |      Set the configuration epoch in a new node
 |
 |      Sends to specefied node
 |
 |  cluster_setslot(self, node_id, slot_id, state, bind_to_node_id=None)
 |      Bind an hash slot to a specific node
 |
 |      Sends to specefied node
 |
 |  cluster_slaves(self, target_node_id)
 |      Force a node cluster to handshake with another node
 |
 |      Sends to targeted cluster node
 |
 |  cluster_slots(self)
 |      Get array of Cluster slot to node mappings
 |
 |      Sends to random node in the cluster
 |
 |  delete(self, *names)
 |      "Delete one or more keys specified by ``names``"
 |
 |      Cluster impl:
 |          Iterate all keys and send DELETE for each key.
 |          This will go a lot slower than a normal delete call in StrictRedis.
 |
 |          Operation is no longer atomic.
 |
 |  determine_node(self, *args, **kwargs)
 |
 |  execute_command(*args, **kwargs)
 |      Send a command to a node in the cluster
 |
 |  mget(self, keys, *args)
 |      Returns a list of values ordered identically to ``keys``
 |
 |      Cluster impl:
 |          Itterate all keys and send GET for each key.
 |          This will go alot slower than a normal mget call in StrictRedis.
 |
 |          Operation is no longer atomic.
 |
 |  mset(self, *args, **kwargs)
 |      Sets key/values based on a mapping. Mapping can be supplied as a single
 |      dictionary argument or as kwargs.
 |
 |      Cluster impl:
 |          Itterate over all items and do SET on each (k,v) pair
 |
 |          Operation is no longer atomic.
 |
 |  msetnx(self, *args, **kwargs)
 |      Sets key/values based on a mapping if none of the keys are already set.
 |      Mapping can be supplied as a single dictionary argument or as kwargs.
 |      Returns a boolean indicating if the operation was successful.
 |
 |      Clutser impl:
 |          Itterate over all items and do GET to determine if all keys do not exists.
 |          If true then call mset() on all keys.
 |
 |  pfcount(self, *sources)
 |      pfcount only works when all sources point to the same hash slot.
 |
 |  pfmerge(self, dest, *sources)
 |      Merge N different HyperLogLogs into a single one.
 |
 |      Cluster impl:
 |          Very special implementation is required to make pfmerge() work
 |          But it works :]
 |          It works by first fetching all HLL objects that should be merged and
 |          move them to one hashslot so that pfmerge operation can be performed without
 |          any 'CROSSSLOT' error.
 |          After the PFMERGE operation is done then it will be moved to the correct location
 |          within the cluster and cleanup is done.
 |
 |          This operation is no longer atomic because of all the operations that has to be done.
 |
 |  pipeline(self, transaction=None, shard_hint=None)
 |      Cluster impl:
 |          Pipelines do not work in cluster mode the same way they do in normal mode.
 |          Create a clone of this object so that simulating pipelines will work correctly.
 |          Each command will be called directly when used and when calling execute() will only return the result stack.
 |
 |  pubsub(self, **kwargs)
 |
 |  pubsub_channels(self, pattern='*', aggregate=True)
 |      Return a list of channels that have at least one subscriber.
 |      Aggregate toggles merging of response.
 |
 |  pubsub_numpat(self, aggregate=True)
 |      Returns the number of subscriptions to patterns.
 |      Aggregate toggles merging of response.
 |
 |  pubsub_numsub(self, *args, **kwargs)
 |      Return a list of (channel, number of subscribers) tuples
 |      for each channel given in ``*args``.
 |
 |      ``aggregate`` keyword argument toggles merging of response.
 |
 |  rename(self, src, dst)
 |      Rename key ``src`` to ``dst``
 |
 |      Cluster impl:
 |          This operation is no longer atomic because each key must be querried
 |          then set in separate calls because they maybe will change cluster node
 |
 |  renamenx(self, src, dst)
 |      Rename key ``src`` to ``dst`` if ``dst`` doesn't already exist
 |
 |      Cluster impl:
 |          Check if dst key do not exists, then calls rename().
 |
 |          Operation is no longer atomic.
 |
 |  rpoplpush(self, src, dst)
 |      RPOP a value off of the ``src`` list and atomically LPUSH it
 |      on to the ``dst`` list.  Returns the value.
 |
 |      Cluster impl:
 |          Call rpop() then send the result into lpush()
 |
 |          Operation is no longer atomic.
 |
 |  scan_iter(self, match=None, count=None)
 |      Make an iterator using the SCAN command so that the client doesn't
 |      need to remember the cursor position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |      ``count`` allows for hint the minimum number of returns
 |
 |      Cluster impl:
 |          Result from SCAN is different in cluster mode.
 |
 |  sdiff(self, keys, *args)
 |      Return the difference of sets specified by ``keys``
 |
 |      Cluster impl:
 |          Querry all keys and diff all sets and return result
 |
 |  sdiffstore(self, dest, keys, *args)
 |      Store the difference of sets specified by ``keys`` into a new
 |      set named ``dest``.  Returns the number of keys in the new set.
 |      Overwrites dest key if it exists.
 |
 |      Cluster impl:
 |          Use sdiff() --> Delete dest key --> store result in dest key
 |
 |  set_result_callback(self, command, callback)
 |      Set a custom Result Callback
 |
 |  sinter(self, keys, *args)
 |      Return the intersection of sets specified by ``keys``
 |
 |      Cluster impl:
 |          Querry all keys, intersection and return result
 |
 |  sinterstore(self, dest, keys, *args)
 |      Store the intersection of sets specified by ``keys`` into a new
 |      set named ``dest``.  Returns the number of keys in the new set.
 |
 |      Cluster impl:
 |          Use sinter() --> Delete dest key --> store result in dest key
 |
 |  smove(self, src, dst, value)
 |      Move ``value`` from set ``src`` to set ``dst`` atomically
 |
 |      Cluster impl:
 |          SMEMBERS --> SREM --> SADD. Function is no longer atomic.
 |
 |  sort(self, name, start=None, num=None, by=None, get=None, desc=False, alpha=False, store=None, groups=None)
 |      Sort and return the list, set or sorted set at ``name``.
 |
 |      :start: and :num:
 |          allow for paging through the sorted data
 |
 |      :by:
 |          allows using an external key to weight and sort the items.
 |          Use an "*" to indicate where in the key the item value is located
 |
 |      :get:
 |          allows for returning items from external keys rather than the
 |          sorted data itself.  Use an "*" to indicate where int he key
 |          the item value is located
 |
 |      :desc:
 |          allows for reversing the sort
 |
 |      :alpha:
 |          allows for sorting lexicographically rather than numerically
 |
 |      :store:
 |          allows for storing the result of the sort into the key `store`
 |
 |      ClusterImpl:
 |          A full implementation of the server side sort mechanics because many of the
 |          options work on multiple keys that can exist on multiple servers.
 |
 |  sunion(self, keys, *args)
 |      Return the union of sets specified by ``keys``
 |
 |      Cluster impl:
 |          Querry all keys, union and return result
 |
 |          Operation is no longer atomic.
 |
 |  sunionstore(self, dest, keys, *args)
 |      Store the union of sets specified by ``keys`` into a new
 |      set named ``dest``.  Returns the number of keys in the new set.
 |
 |      Cluster impl:
 |          Use sunion() --> Dlete dest key --> store result in dest key
 |
 |          Operation is no longer atomic.
 |
 |  transaction(self, *args, **kwargs)
 |      Transaction is not implemented in cluster mode yet.
 |
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |
 |  from_url(cls, url, db=None, skip_full_coverage_check=False, **kwargs) from __builtin__.type
 |      Return a Redis client object configured from the given URL, which must
 |      use either `the ``redis://`` scheme
 |      <http://www.iana.org/assignments/uri-schemes/prov/redis>`_ for RESP
 |      connections or the ``unix://`` scheme for Unix domain sockets.
 |      For example::
 |          redis://[:password]@localhost:6379/0
 |          unix://[:password]@/path/to/socket.sock?db=0
 |      There are several ways to specify a database number. The parse function
 |      will return the first specified option:
 |          1. A ``db`` querystring option, e.g. redis://localhost?db=0
 |          2. If using the redis:// scheme, the path argument of the url, e.g.
 |             redis://localhost/0
 |          3. The ``db`` argument to this function.
 |      If none of these options are specified, db=0 is used.
 |      Any additional querystring arguments and keyword arguments will be
 |      passed along to the ConnectionPool class's initializer. In the case
 |      of conflicting arguments, querystring arguments always win.
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |
 |  CLUSTER_COMMANDS_RESPONSE_CALLBACKS = {'ASKING': <function bool_ok>, '...
 |
 |  NODES_FLAGS = {'BGREWRITEAOF': 'all-nodes', 'BGSAVE': 'all-nodes', 'BI...
 |
 |  RESULT_CALLBACKS = {'BGREWRITEAOF': <function <lambda>>, 'BGSAVE': <fu...
 |
 |  RedisClusterRequestTTL = 16
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from redis.client.StrictRedis:
 |
 |  __contains__ = exists(self, name)
 |      Returns a boolean indicating whether key ``name`` exists
 |
 |  __delitem__(self, name)
 |
 |  __getitem__(self, name)
 |      Return the value at key ``name``, raises a KeyError if the key
 |      doesn't exist.
 |
 |  __setitem__(self, name, value)
 |
 |  append(self, key, value)
 |      Appends the string ``value`` to the value at ``key``. If ``key``
 |      doesn't already exist, create it with a value of ``value``.
 |      Returns the new length of the value at ``key``.
 |
 |  bgrewriteaof(self)
 |      Tell the Redis server to rewrite the AOF file from data in memory.
 |
 |  bgsave(self)
 |      Tell the Redis server to save its data to disk.  Unlike save(),
 |      this method is asynchronous and returns immediately.
 |
 |  bitcount(self, key, start=None, end=None)
 |      Returns the count of set bits in the value of ``key``.  Optional
 |      ``start`` and ``end`` paramaters indicate which bytes to consider
 |
 |  bitop(self, operation, dest, *keys)
 |      Perform a bitwise operation using ``operation`` between ``keys`` and
 |      store the result in ``dest``.
 |
 |  bitpos(self, key, bit, start=None, end=None)
 |      Return the position of the first bit set to 1 or 0 in a string.
 |      ``start`` and ``end`` difines search range. The range is interpreted
 |      as a range of bytes and not a range of bits, so start=0 and end=2
 |      means to look at the first three bytes.
 |
 |  blpop(self, keys, timeout=0)
 |      LPOP a value off of the first non-empty list
 |      named in the ``keys`` list.
 |
 |      If none of the lists in ``keys`` has a value to LPOP, then block
 |      for ``timeout`` seconds, or until a value gets pushed on to one
 |      of the lists.
 |
 |      If timeout is 0, then block indefinitely.
 |
 |  brpop(self, keys, timeout=0)
 |      RPOP a value off of the first non-empty list
 |      named in the ``keys`` list.
 |
 |      If none of the lists in ``keys`` has a value to RPOP, then block
 |      for ``timeout`` seconds, or until a value gets pushed on to one
 |      of the lists.
 |
 |      If timeout is 0, then block indefinitely.
 |
 |  client_getname(self)
 |      Returns the current connection name
 |
 |  client_kill(self, address)
 |      Disconnects the client at ``address`` (ip:port)
 |
 |  client_list(self)
 |      Returns a list of currently connected clients
 |
 |  client_setname(self, name)
 |      Sets the current connection name
 |
 |  cluster(self, cluster_arg, *args)
 |
 |  config_get(self, pattern='*')
 |      Return a dictionary of configuration based on the ``pattern``
 |
 |  config_resetstat(self)
 |      Reset runtime statistics
 |
 |  config_rewrite(self)
 |      Rewrite config file with the minimal change to reflect running config
 |
 |  config_set(self, name, value)
 |      Set config item ``name`` with ``value``
 |
 |  dbsize(self)
 |      Returns the number of keys in the current database
 |
 |  debug_object(self, key)
 |      Returns version specific meta information about a given key
 |
 |  decr(self, name, amount=1)
 |      Decrements the value of ``key`` by ``amount``.  If no key exists,
 |      the value will be initialized as 0 - ``amount``
 |
 |  dump(self, name)
 |      Return a serialized version of the value stored at the specified key.
 |      If key does not exist a nil bulk reply is returned.
 |
 |  echo(self, value)
 |      Echo the string back from the server
 |
 |  eval(self, script, numkeys, *keys_and_args)
 |      Execute the Lua ``script``, specifying the ``numkeys`` the script
 |      will touch and the key names and argument values in ``keys_and_args``.
 |      Returns the result of the script.
 |
 |      In practice, use the object returned by ``register_script``. This
 |      function exists purely for Redis API completion.
 |
 |  evalsha(self, sha, numkeys, *keys_and_args)
 |      Use the ``sha`` to execute a Lua script already registered via EVAL
 |      or SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the
 |      key names and argument values in ``keys_and_args``. Returns the result
 |      of the script.
 |
 |      In practice, use the object returned by ``register_script``. This
 |      function exists purely for Redis API completion.
 |
 |  exists(self, name)
 |      Returns a boolean indicating whether key ``name`` exists
 |
 |  expire(self, name, time)
 |      Set an expire flag on key ``name`` for ``time`` seconds. ``time``
 |      can be represented by an integer or a Python timedelta object.
 |
 |  expireat(self, name, when)
 |      Set an expire flag on key ``name``. ``when`` can be represented
 |      as an integer indicating unix time or a Python datetime object.
 |
 |  flushall(self)
 |      Delete all keys in all databases on the current host
 |
 |  flushdb(self)
 |      Delete all keys in the current database
 |
 |  geoadd(self, name, *values)
 |      Add the specified geospatial items to the specified key identified
 |      by the ``name`` argument. The Geospatial items are given as ordered
 |      members of the ``values`` argument, each item or place is formed by
 |      the triad longitude, latitude and name.
 |
 |  geodist(self, name, place1, place2, unit=None)
 |      Return the distance between ``place1`` and ``place2`` members of the
 |      ``name`` key.
 |      The units must be one of the following : m, km mi, ft. By default
 |      meters are used.
 |
 |  geohash(self, name, *values)
 |      Return the geo hash string for each item of ``values`` members of
 |      the specified key identified by the ``name``argument.
 |
 |  geopos(self, name, *values)
 |      Return the positions of each item of ``values`` as members of
 |      the specified key identified by the ``name``argument. Each position
 |      is represented by the pairs lon and lat.
 |
 |  georadius(self, name, longitude, latitude, radius, unit=None, withdist=False, withcoord=False, withhash=False, count=None, sort=None, store=None, store_dist=None)
 |      Return the members of the specified key identified by the
 |      ``name`` argument which are within the borders of the area specified
 |      with the ``latitude`` and ``longitude`` location and the maximum
 |      distance from the center specified by the ``radius`` value.
 |
 |      The units must be one of the following : m, km mi, ft. By default
 |
 |      ``withdist`` indicates to return the distances of each place.
 |
 |      ``withcoord`` indicates to return the latitude and longitude of
 |      each place.
 |
 |      ``withhash`` indicates to return the geohash string of each place.
 |
 |      ``count`` indicates to return the number of elements up to N.
 |
 |      ``sort`` indicates to return the places in a sorted way, ASC for
 |      nearest to fairest and DESC for fairest to nearest.
 |
 |      ``store`` indicates to save the places names in a sorted set named
 |      with a specific key, each element of the destination sorted set is
 |      populated with the score got from the original geo sorted set.
 |
 |      ``store_dist`` indicates to save the places names in a sorted set
 |      named with a specific key, instead of ``store`` the sorted set
 |      destination score is set with the distance.
 |
 |  georadiusbymember(self, name, member, radius, unit=None, withdist=False, withcoord=False, withhash=False, count=None, sort=None, store=None, store_dist=None)
 |      This command is exactly like ``georadius`` with the sole difference
 |      that instead of taking, as the center of the area to query, a longitude
 |      and latitude value, it takes the name of a member already existing
 |      inside the geospatial index represented by the sorted set.
 |
 |  get(self, name)
 |      Return the value at key ``name``, or None if the key doesn't exist
 |
 |  getbit(self, name, offset)
 |      Returns a boolean indicating the value of ``offset`` in ``name``
 |
 |  getrange(self, key, start, end)
 |      Returns the substring of the string value stored at ``key``,
 |      determined by the offsets ``start`` and ``end`` (both are inclusive)
 |
 |  getset(self, name, value)
 |      Sets the value at key ``name`` to ``value``
 |      and returns the old value at key ``name`` atomically.
 |
 |  hdel(self, name, *keys)
 |      Delete ``keys`` from hash ``name``
 |
 |  hexists(self, name, key)
 |      Returns a boolean indicating if ``key`` exists within hash ``name``
 |
 |  hget(self, name, key)
 |      Return the value of ``key`` within the hash ``name``
 |
 |  hgetall(self, name)
 |      Return a Python dict of the hash's name/value pairs
 |
 |  hincrby(self, name, key, amount=1)
 |      Increment the value of ``key`` in hash ``name`` by ``amount``
 |
 |  hincrbyfloat(self, name, key, amount=1.0)
 |      Increment the value of ``key`` in hash ``name`` by floating ``amount``
 |
 |  hkeys(self, name)
 |      Return the list of keys within hash ``name``
 |
 |  hlen(self, name)
 |      Return the number of elements in hash ``name``
 |
 |  hmget(self, name, keys, *args)
 |      Returns a list of values ordered identically to ``keys``
 |
 |  hmset(self, name, mapping)
 |      Set key to value within hash ``name`` for each corresponding
 |      key and value from the ``mapping`` dict.
 |
 |  hscan(self, name, cursor=0, match=None, count=None)
 |      Incrementally return key/value slices in a hash. Also return a cursor
 |      indicating the scan position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |
 |      ``count`` allows for hint the minimum number of returns
 |
 |  hscan_iter(self, name, match=None, count=None)
 |      Make an iterator using the HSCAN command so that the client doesn't
 |      need to remember the cursor position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |
 |      ``count`` allows for hint the minimum number of returns
 |
 |  hset(self, name, key, value)
 |      Set ``key`` to ``value`` within hash ``name``
 |      Returns 1 if HSET created a new field, otherwise 0
 |
 |  hsetnx(self, name, key, value)
 |      Set ``key`` to ``value`` within hash ``name`` if ``key`` does not
 |      exist.  Returns 1 if HSETNX created a field, otherwise 0.
 |
 |  hstrlen(self, name, key)
 |      Return the number of bytes stored in the value of ``key``
 |      within hash ``name``
 |
 |  hvals(self, name)
 |      Return the list of values within hash ``name``
 |
 |  incr(self, name, amount=1)
 |      Increments the value of ``key`` by ``amount``.  If no key exists,
 |      the value will be initialized as ``amount``
 |
 |  incrby(self, name, amount=1)
 |      Increments the value of ``key`` by ``amount``.  If no key exists,
 |      the value will be initialized as ``amount``
 |
 |  incrbyfloat(self, name, amount=1.0)
 |      Increments the value at key ``name`` by floating ``amount``.
 |      If no key exists, the value will be initialized as ``amount``
 |
 |  info(self, section=None)
 |      Returns a dictionary containing information about the Redis server
 |
 |      The ``section`` option can be used to select a specific section
 |      of information
 |
 |      The section option is not supported by older versions of Redis Server,
 |      and will generate ResponseError
 |
 |  keys(self, pattern='*')
 |      Returns a list of keys matching ``pattern``
 |
 |  lastsave(self)
 |      Return a Python datetime object representing the last time the
 |      Redis database was saved to disk
 |
 |  lindex(self, name, index)
 |      Return the item from list ``name`` at position ``index``
 |
 |      Negative indexes are supported and will return an item at the
 |      end of the list
 |
 |  linsert(self, name, where, refvalue, value)
 |      Insert ``value`` in list ``name`` either immediately before or after
 |      [``where``] ``refvalue``
 |
 |      Returns the new length of the list on success or -1 if ``refvalue``
 |      is not in the list.
 |
 |  llen(self, name)
 |      Return the length of the list ``name``
 |
 |  lock(self, name, timeout=None, sleep=0.1, blocking_timeout=None, lock_class=None, thread_local=True)
 |      Return a new Lock object using key ``name`` that mimics
 |      the behavior of threading.Lock.
 |
 |      If specified, ``timeout`` indicates a maximum life for the lock.
 |      By default, it will remain locked until release() is called.
 |
 |      ``sleep`` indicates the amount of time to sleep per loop iteration
 |      when the lock is in blocking mode and another client is currently
 |      holding the lock.
 |
 |      ``blocking_timeout`` indicates the maximum amount of time in seconds to
 |      spend trying to acquire the lock. A value of ``None`` indicates
 |      continue trying forever. ``blocking_timeout`` can be specified as a
 |      float or integer, both representing the number of seconds to wait.
 |
 |      ``lock_class`` forces the specified lock implementation.
 |
 |      ``thread_local`` indicates whether the lock token is placed in
 |      thread-local storage. By default, the token is placed in thread local
 |      storage so that a thread only sees its token, not a token set by
 |      another thread. Consider the following timeline:
 |
 |          time: 0, thread-1 acquires `my-lock`, with a timeout of 5 seconds.
 |                   thread-1 sets the token to "abc"
 |          time: 1, thread-2 blocks trying to acquire `my-lock` using the
 |                   Lock instance.
 |          time: 5, thread-1 has not yet completed. redis expires the lock
 |                   key.
 |          time: 5, thread-2 acquired `my-lock` now that it's available.
 |                   thread-2 sets the token to "xyz"
 |          time: 6, thread-1 finishes its work and calls release(). if the
 |                   token is *not* stored in thread local storage, then
 |                   thread-1 would see the token value as "xyz" and would be
 |                   able to successfully release the thread-2's lock.
 |
 |      In some use cases it's necessary to disable thread local storage. For
 |      example, if you have code where one thread acquires a lock and passes
 |      that lock instance to a worker thread to release later. If thread
 |      local storage isn't disabled in this case, the worker thread won't see
 |      the token set by the thread that acquired the lock. Our assumption
 |      is that these cases aren't common and as such default to using
 |      thread local storage.
 |
 |  lpop(self, name)
 |      Remove and return the first item of the list ``name``
 |
 |  lpush(self, name, *values)
 |      Push ``values`` onto the head of the list ``name``
 |
 |  lpushx(self, name, value)
 |      Push ``value`` onto the head of the list ``name`` if ``name`` exists
 |
 |  lrange(self, name, start, end)
 |      Return a slice of the list ``name`` between
 |      position ``start`` and ``end``
 |
 |      ``start`` and ``end`` can be negative numbers just like
 |      Python slicing notation
 |
 |  lrem(self, name, count, value)
 |      Remove the first ``count`` occurrences of elements equal to ``value``
 |      from the list stored at ``name``.
 |
 |      The count argument influences the operation in the following ways:
 |          count > 0: Remove elements equal to value moving from head to tail.
 |          count < 0: Remove elements equal to value moving from tail to head.
 |          count = 0: Remove all elements equal to value.
 |
 |  lset(self, name, index, value)
 |      Set ``position`` of list ``name`` to ``value``
 |
 |  ltrim(self, name, start, end)
 |      Trim the list ``name``, removing all values not within the slice
 |      between ``start`` and ``end``
 |
 |      ``start`` and ``end`` can be negative numbers just like
 |      Python slicing notation
 |
 |  move(self, name, db)
 |      Moves the key ``name`` to a different Redis database ``db``
 |
 |  object(self, infotype, key)
 |      Return the encoding, idletime, or refcount about the key
 |
 |  parse_response(self, connection, command_name, **options)
 |      Parses a response from the Redis server
 |
 |  persist(self, name)
 |      Removes an expiration on ``name``
 |
 |  pexpire(self, name, time)
 |      Set an expire flag on key ``name`` for ``time`` milliseconds.
 |      ``time`` can be represented by an integer or a Python timedelta
 |      object.
 |
 |  pexpireat(self, name, when)
 |      Set an expire flag on key ``name``. ``when`` can be represented
 |      as an integer representing unix time in milliseconds (unix time * 1000)
 |      or a Python datetime object.
 |
 |  pfadd(self, name, *values)
 |      Adds the specified elements to the specified HyperLogLog.
 |
 |  ping(self)
 |      Ping the Redis server
 |
 |  psetex(self, name, time_ms, value)
 |      Set the value of key ``name`` to ``value`` that expires in ``time_ms``
 |      milliseconds. ``time_ms`` can be represented by an integer or a Python
 |      timedelta object
 |
 |  pttl(self, name)
 |      Returns the number of milliseconds until the key ``name`` will expire
 |
 |  publish(self, channel, message)
 |      Publish ``message`` on ``channel``.
 |      Returns the number of subscribers the message was delivered to.
 |
 |  randomkey(self)
 |      Returns the name of a random key
 |
 |  register_script(self, script)
 |      Register a Lua ``script`` specifying the ``keys`` it will touch.
 |      Returns a Script object that is callable and hides the complexity of
 |      deal with scripts, keys, and shas. This is the preferred way to work
 |      with Lua scripts.
 |
 |  restore(self, name, ttl, value, replace=False)
 |      Create a key using the provided serialized value, previously obtained
 |      using DUMP.
 |
 |  rpop(self, name)
 |      Remove and return the last item of the list ``name``
 |
 |  rpush(self, name, *values)
 |      Push ``values`` onto the tail of the list ``name``
 |
 |  rpushx(self, name, value)
 |      Push ``value`` onto the tail of the list ``name`` if ``name`` exists
 |
 |  sadd(self, name, *values)
 |      Add ``value(s)`` to set ``name``
 |
 |  save(self)
 |      Tell the Redis server to save its data to disk,
 |      blocking until the save is complete
 |
 |  scan(self, cursor=0, match=None, count=None)
 |      Incrementally return lists of key names. Also return a cursor
 |      indicating the scan position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |
 |      ``count`` allows for hint the minimum number of returns
 |
 |  scard(self, name)
 |      Return the number of elements in set ``name``
 |
 |  script_exists(self, *args)
 |      Check if a script exists in the script cache by specifying the SHAs of
 |      each script as ``args``. Returns a list of boolean values indicating if
 |      if each already script exists in the cache.
 |
 |  script_flush(self)
 |      Flush all scripts from the script cache
 |
 |  script_kill(self)
 |      Kill the currently executing Lua script
 |
 |  script_load(self, script)
 |      Load a Lua ``script`` into the script cache. Returns the SHA.
 |
 |  sentinel(self, *args)
 |      Redis Sentinel's SENTINEL command.
 |
 |  sentinel_get_master_addr_by_name(self, service_name)
 |      Returns a (host, port) pair for the given ``service_name``
 |
 |  sentinel_master(self, service_name)
 |      Returns a dictionary containing the specified masters state.
 |
 |  sentinel_masters(self)
 |      Returns a list of dictionaries containing each master's state.
 |
 |  sentinel_monitor(self, name, ip, port, quorum)
 |      Add a new master to Sentinel to be monitored
 |
 |  sentinel_remove(self, name)
 |      Remove a master from Sentinel's monitoring
 |
 |  sentinel_sentinels(self, service_name)
 |      Returns a list of sentinels for ``service_name``
 |
 |  sentinel_set(self, name, option, value)
 |      Set Sentinel monitoring parameters for a given master
 |
 |  sentinel_slaves(self, service_name)
 |      Returns a list of slaves for ``service_name``
 |
 |  set(self, name, value, ex=None, px=None, nx=False, xx=False)
 |      Set the value at key ``name`` to ``value``
 |
 |      ``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.
 |
 |      ``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.
 |
 |      ``nx`` if set to True, set the value at key ``name`` to ``value`` only
 |          if it does not exist.
 |
 |      ``xx`` if set to True, set the value at key ``name`` to ``value`` only
 |          if it already exists.
 |
 |  set_response_callback(self, command, callback)
 |      Set a custom Response Callback
 |
 |  setbit(self, name, offset, value)
 |      Flag the ``offset`` in ``name`` as ``value``. Returns a boolean
 |      indicating the previous value of ``offset``.
 |
 |  setex(self, name, time, value)
 |      Set the value of key ``name`` to ``value`` that expires in ``time``
 |      seconds. ``time`` can be represented by an integer or a Python
 |      timedelta object.
 |
 |  setnx(self, name, value)
 |      Set the value of key ``name`` to ``value`` if key doesn't exist
 |
 |  setrange(self, name, offset, value)
 |      Overwrite bytes in the value of ``name`` starting at ``offset`` with
 |      ``value``. If ``offset`` plus the length of ``value`` exceeds the
 |      length of the original value, the new value will be larger than before.
 |      If ``offset`` exceeds the length of the original value, null bytes
 |      will be used to pad between the end of the previous value and the start
 |      of what's being injected.
 |
 |      Returns the length of the new string.
 |
 |  shutdown(self)
 |      Shutdown the server
 |
 |  sismember(self, name, value)
 |      Return a boolean indicating if ``value`` is a member of set ``name``
 |
 |  slaveof(self, host=None, port=None)
 |      Set the server to be a replicated slave of the instance identified
 |      by the ``host`` and ``port``. If called without arguments, the
 |      instance is promoted to a master instead.
 |
 |  slowlog_get(self, num=None)
 |      Get the entries from the slowlog. If ``num`` is specified, get the
 |      most recent ``num`` items.
 |
 |  slowlog_len(self)
 |      Get the number of items in the slowlog
 |
 |  slowlog_reset(self)
 |      Remove all items in the slowlog
 |
 |  smembers(self, name)
 |      Return all members of the set ``name``
 |
 |  spop(self, name)
 |      Remove and return a random member of set ``name``
 |
 |  srandmember(self, name, number=None)
 |      If ``number`` is None, returns a random member of set ``name``.
 |
 |      If ``number`` is supplied, returns a list of ``number`` random
 |      memebers of set ``name``. Note this is only available when running
 |      Redis 2.6+.
 |
 |  srem(self, name, *values)
 |      Remove ``values`` from set ``name``
 |
 |  sscan(self, name, cursor=0, match=None, count=None)
 |      Incrementally return lists of elements in a set. Also return a cursor
 |      indicating the scan position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |
 |      ``count`` allows for hint the minimum number of returns
 |
 |  sscan_iter(self, name, match=None, count=None)
 |      Make an iterator using the SSCAN command so that the client doesn't
 |      need to remember the cursor position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |
 |      ``count`` allows for hint the minimum number of returns
 |
 |  strlen(self, name)
 |      Return the number of bytes stored in the value of ``name``
 |
 |  substr(self, name, start, end=-1)
 |      Return a substring of the string at key ``name``. ``start`` and ``end``
 |      are 0-based integers specifying the portion of the string to return.
 |
 |  time(self)
 |      Returns the server time as a 2-item tuple of ints:
 |      (seconds since epoch, microseconds into this second).
 |
 |  touch(self, *args)
 |      Alters the last access time of a key(s) ``*args``. A key is ignored
 |      if it does not exist.
 |
 |  ttl(self, name)
 |      Returns the number of seconds until the key ``name`` will expire
 |
 |  type(self, name)
 |      Returns the type of key ``name``
 |
 |  unwatch(self)
 |      Unwatches the value at key ``name``, or None of the key doesn't exist
 |
 |  wait(self, num_replicas, timeout)
 |      Redis synchronous replication
 |      That returns the number of replicas that processed the query when
 |      we finally have at least ``num_replicas``, or when the ``timeout`` was
 |      reached.
 |
 |  watch(self, *names)
 |      Watches the values at keys ``names``, or None if the key doesn't exist
 |
 |  zadd(self, name, *args, **kwargs)
 |      Set any number of score, element-name pairs to the key ``name``. Pairs
 |      can be specified in two ways:
 |
 |      As *args, in the form of: score1, name1, score2, name2, ...
 |      or as **kwargs, in the form of: name1=score1, name2=score2, ...
 |
 |      The following example would add four values to the 'my-key' key:
 |      redis.zadd('my-key', 1.1, 'name1', 2.2, 'name2', name3=3.3, name4=4.4)
 |
 |  zcard(self, name)
 |      Return the number of elements in the sorted set ``name``
 |
 |  zcount(self, name, min, max)
 |      Returns the number of elements in the sorted set at key ``name`` with
 |      a score between ``min`` and ``max``.
 |
 |  zincrby(self, name, value, amount=1)
 |      Increment the score of ``value`` in sorted set ``name`` by ``amount``
 |
 |  zinterstore(self, dest, keys, aggregate=None)
 |      Intersect multiple sorted sets specified by ``keys`` into
 |      a new sorted set, ``dest``. Scores in the destination will be
 |      aggregated based on the ``aggregate``, or SUM if none is provided.
 |
 |  zlexcount(self, name, min, max)
 |      Return the number of items in the sorted set ``name`` between the
 |      lexicographical range ``min`` and ``max``.
 |
 |  zrange(self, name, start, end, desc=False, withscores=False, score_cast_func=<type 'float'>)
 |      Return a range of values from sorted set ``name`` between
 |      ``start`` and ``end`` sorted in ascending order.
 |
 |      ``start`` and ``end`` can be negative, indicating the end of the range.
 |
 |      ``desc`` a boolean indicating whether to sort the results descendingly
 |
 |      ``withscores`` indicates to return the scores along with the values.
 |      The return type is a list of (value, score) pairs
 |
 |      ``score_cast_func`` a callable used to cast the score return value
 |
 |  zrangebylex(self, name, min, max, start=None, num=None)
 |      Return the lexicographical range of values from sorted set ``name``
 |      between ``min`` and ``max``.
 |
 |      If ``start`` and ``num`` are specified, then return a slice of the
 |      range.
 |
 |  zrangebyscore(self, name, min, max, start=None, num=None, withscores=False, score_cast_func=<type 'float'>)
 |      Return a range of values from the sorted set ``name`` with scores
 |      between ``min`` and ``max``.
 |
 |      If ``start`` and ``num`` are specified, then return a slice
 |      of the range.
 |
 |      ``withscores`` indicates to return the scores along with the values.
 |      The return type is a list of (value, score) pairs
 |
 |      `score_cast_func`` a callable used to cast the score return value
 |
 |  zrank(self, name, value)
 |      Returns a 0-based value indicating the rank of ``value`` in sorted set
 |      ``name``
 |
 |  zrem(self, name, *values)
 |      Remove member ``values`` from sorted set ``name``
 |
 |  zremrangebylex(self, name, min, max)
 |      Remove all elements in the sorted set ``name`` between the
 |      lexicographical range specified by ``min`` and ``max``.
 |
 |      Returns the number of elements removed.
 |
 |  zremrangebyrank(self, name, min, max)
 |      Remove all elements in the sorted set ``name`` with ranks between
 |      ``min`` and ``max``. Values are 0-based, ordered from smallest score
 |      to largest. Values can be negative indicating the highest scores.
 |      Returns the number of elements removed
 |
 |  zremrangebyscore(self, name, min, max)
 |      Remove all elements in the sorted set ``name`` with scores
 |      between ``min`` and ``max``. Returns the number of elements removed.
 |
 |  zrevrange(self, name, start, end, withscores=False, score_cast_func=<type 'float'>)
 |      Return a range of values from sorted set ``name`` between
 |      ``start`` and ``end`` sorted in descending order.
 |
 |      ``start`` and ``end`` can be negative, indicating the end of the range.
 |
 |      ``withscores`` indicates to return the scores along with the values
 |      The return type is a list of (value, score) pairs
 |
 |      ``score_cast_func`` a callable used to cast the score return value
 |
 |  zrevrangebylex(self, name, max, min, start=None, num=None)
 |      Return the reversed lexicographical range of values from sorted set
 |      ``name`` between ``max`` and ``min``.
 |
 |      If ``start`` and ``num`` are specified, then return a slice of the
 |      range.
 |
 |  zrevrangebyscore(self, name, max, min, start=None, num=None, withscores=False, score_cast_func=<type 'float'>)
 |      Return a range of values from the sorted set ``name`` with scores
 |      between ``min`` and ``max`` in descending order.
 |
 |      If ``start`` and ``num`` are specified, then return a slice
 |      of the range.
 |
 |      ``withscores`` indicates to return the scores along with the values.
 |      The return type is a list of (value, score) pairs
 |
 |      ``score_cast_func`` a callable used to cast the score return value
 |
 |  zrevrank(self, name, value)
 |      Returns a 0-based value indicating the descending rank of
 |      ``value`` in sorted set ``name``
 |
 |  zscan(self, name, cursor=0, match=None, count=None, score_cast_func=<type 'float'>)
 |      Incrementally return lists of elements in a sorted set. Also return a
 |      cursor indicating the scan position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |
 |      ``count`` allows for hint the minimum number of returns
 |
 |      ``score_cast_func`` a callable used to cast the score return value
 |
 |  zscan_iter(self, name, match=None, count=None, score_cast_func=<type 'float'>)
 |      Make an iterator using the ZSCAN command so that the client doesn't
 |      need to remember the cursor position.
 |
 |      ``match`` allows for filtering the keys by pattern
 |
 |      ``count`` allows for hint the minimum number of returns
 |
 |      ``score_cast_func`` a callable used to cast the score return value
 |
 |  zscore(self, name, value)
 |      Return the score of element ``value`` in sorted set ``name``
 |
 |  zunionstore(self, dest, keys, aggregate=None)
 |      Union multiple sorted sets specified by ``keys`` into
 |      a new sorted set, ``dest``. Scores in the destination will be
 |      aggregated based on the ``aggregate``, or SUM if none is provided.
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from redis.client.StrictRedis:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from redis.client.StrictRedis:
 |
 |  RESPONSE_CALLBACKS = {'AUTH': <type 'bool'>, 'BGREWRITEAOF': <function...

None
a
conf\10.22\dc.txt />